<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sword | Thinking in Crowd / 鹄思乱想]]></title>
  <link href="http://www.thinkingincrowd.me/blog/categories/sword/atom.xml" rel="self"/>
  <link href="http://www.thinkingincrowd.me/"/>
  <updated>2012-11-05T21:31:03+08:00</updated>
  <id>http://www.thinkingincrowd.me/</id>
  <author>
    <name><![CDATA[鹄思乱想]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个多维度数据匹配的RDBMS数据库表设计的想法]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2012/10/27/db-design-for-multi-dimension-data/"/>
    <updated>2012-10-27T23:48:37+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2012/10/27/db-design-for-multi-dimension-data</id>
    <content type="html"><![CDATA[<p>首先, 我先要说明一下, 这里的“多维度”可能并不太准确.  这里说的并不是数据仓库里的维度, 而只是数据的属性.</p>

<p>举个例子可能就比较好明白了.</p>

<p>比如, 如果你上京东, 或者苏宁一些网上商场买电脑, 上面一堆的过滤条件 (比如: CPU, 内存, 硬盘等) , 其实就是电脑的属性, 也就是我这里说的数据 (电脑) 的维度。</p>

<p>我最近做的一个系统模块, 其实就是关于数据维度匹配和使用的.  这个模块的大概原理是这样的, 根据一些输入的数据维度值, 在数据库内寻找出维度值和输入的维度值不冲突的数据.</p>

<p>假设数据库现在想保存的数据是眼镜的资料, 那么这些数据的维度有: 材料, 颜色, 设计 (半框, 全框, 等), 面向人群 (青, 中, 老), 面向性别(男, 女).  我现在要做的模块就是当一个人来了, 我把他的相对应的维度 (性别, 喜欢的颜色, 设计, 材料, 等), 输入到数据库中查找匹配的数据 (眼镜), 系统应该要拿出和这个人要求不冲突的.</p>

<p>这个模块要怎么设计呢?  数据库的表要怎么设计呢?  这里假设系统用的是JPA Entity和Oracle DB.</p>

<p>首先应该有一个表是存储了眼镜的信息的 (UUID, 名称, 厂家, 等).  一般来说, 刚才的那些关于眼镜的属性也就是数据维度, 自然的想法, 当然也是放在同一张表里面, 也就是用表里面不同的列, 来存放不同的维度, 比如:</p>

<p>表 GLASSES的列有:</p>

<p>| UUID | 名称 | 厂家 | 材料 | 颜色 | 设计 | 面向人群 | 面向性别 |</p>

<p>那么, 假设一个喜欢红色半框设计眼镜的男人来找眼镜, 根据输入来查寻数据的SQL就会是类似:</p>

<pre><code>SELECT * FROM GLASSES
WHERE 设计 = '半框' AND 颜色 = '红' AND 面向性别 = '男';
</code></pre>

<p>但是, 其实要找出和这个人要求不冲突的眼镜, 情况并不是这样子的.</p>

<p>比如说, 很可能GLASSES表里有些眼镜, 它的某些属性列为空, 假设有一款眼镜并不指定面向性别.  你可能会说SQL就要变成这个样子:</p>

<pre><code>SELECT * FROM GLASSES
WHERE (设计 = '半框' OR 设计 IS NULL)
AND (颜色 = '红' OR 颜色 IS NULL)
AND (面向性别 = '男' OR 面向性别 IS NULL);
</code></pre>

<p>但是, 也有可能这个人对设计没什么偏好.  如果是这样的话, 那可能你就要动态生成SQL, 也就是这个人如果哪个条件没有要求, 哪个条件就不加到SQL里面, 比如对设计没偏好:</p>

<pre><code>SELECT * FROM GLASSES
WHERE (颜色 = '红' OR 颜色 IS NULL)
AND (面向性别 = '男' OR 面向性别 IS NULL);
</code></pre>

<p>到这里, 问题就比较清楚了.  如果从写代码和DB设计来考虑, 属性做为表的列来设计的话, 我个人觉得有几种不好之处:</p>

<ul>
<li><p>如果以后要添加或者删除属性, 表结构要不断改变, 代码也要不断改变来生成各种组合的动态SQL.</p></li>
<li><p>从SQL的特性 (条件不确定, 维度组合多) 来看, 并且如果维度或者说列多的话, 为每一个维度创建index也不太可行, 查询效率也不高.</p></li>
</ul>


<p>所以, 自然的, 我把数据维度的值, 设计成存储在子表里, 结构示例如下:</p>

<p>表GLASSES_ATTRIBUTES:</p>

<p>| UUID | GLASSES_UUID | 维度类别 | 维度值 |</p>

<p>这样的话, 上面的SQL就转换成:</p>

<pre><code>SELECT * FROM GLASSES G
WHERE NOT EXISTS (
    SELECT 1
      FROM GLASSES_ATTRIBUTES GA
    WHERE G.UUID = GA.GLASSES_UUID
              AND (
                    （维度类别 = '颜色‘ AND 维度值 &lt;&gt; '红色')
                     OR
                    （维度类别 = '面向性别‘ AND 维度值 &lt;&gt; '男')
                    )
);
</code></pre>

<p>这条SQL也是需要动态生成的, 也就是最里面的OR的部份.  如果一款眼镜, 它没有定义特定的维度, 那它在子表里面就没有记录, 也满足要求.  如果是那个人没有什么特殊要求, 也就不需要生成特定的OR的部份.</p>

<p>这种实现方法, 个人认为相对来说好处有:</p>

<ul>
<li><p>虽然SQL也要动态生成, 但是变化的部份从表的列名, 转换成数据值, 逻辑会相当简单, 减少一些Hardcode的成份.</p></li>
<li><p>数据库表GLASSES_ATTRIBUTES可以创建一个维度类别+维度值的复合index就可以了</p></li>
</ul>


<p>不过, 老实说, 我也不敢肯定后面一种SQL的查询效率会高点, 因为也会有比较多OR的条件, 并且还要用上NOT EXISTS.  我曾经测试过在GLASSESE里有6W条记录, GLASSES_ATTRIBUTES上有37W条记录的环境里, 用3个维度(也就是3个OR组合), 找出1W条左右记录, 大概0.01秒.  用6个维度, 找出1K条左右记录, 大概0.1秒;  用11个维度, 找出15条记录, 也大概0.2秒左右.  所以, 看起来, 好像还可以.</p>

<p>其实, 我在这里把数据的维度值用行记录来存储, 而不是列值, 还因为实际的系统需求, 还有更多复杂的要求.  再举一个纯属搞笑的例子, 但实际原理是一样的.</p>

<p>比如一个女的要征婚, 她列下了一些要求, 也就是"如果男的xxx, 就要准备yyy之类的.   xxx就是数据 (男) 的维度, 比如年龄30以上, 或者帅, 等.  yyy就是需求, 比如有房, 有车,  年薪,  爱宠物什么的.</p>

<p>这里呢, 会有3个表:</p>

<ul>
<li><p>主表 - 这里的每一条记录, 代表一份要求</p></li>
<li><p>维度子表 (CONDITIONS) - 存的是归到这份要求, 男的情况是什么, 如年龄30以上, 不帅</p></li>
<li><p>需求子表 (REQUIREMENTS) - 存的是归到这份要求, 男的要准备什么, 女的才会嫁他, 如车30W以上, 房要50W以上等</p></li>
</ul>


<p>系统的行为, 就是当把一个男的所有情况输入进去, 就会找到所有女方的需求是什么, 都组合在一起, 作为总的要求.  这种情况下, 系统就复杂了.  比如主表有三条记录A, B, C.  维度和需求分别是:</p>

<pre><code>CONDITIONS:

| A | 年龄 | 30以上 |
| B | 相貌 | 不帅 |
| C | 相貌 | 不帅 |
| C | 宠物 | 不讨厌 |

REQUIREMENTS:
| A | 车 | 20W以上 |
| B | 房 | 50W以上 |
| C | 房 | 40W以上 |
| C | 车 | 有 |
</code></pre>

<p>看得明白吗?  假设一个男的30以上, 那他就要有20W以上的车才行了.  如果他又不帅, 但是讨厌宠物的话, 就要加上50W以上的房了.  既然需求有组合的情况, 不知道你们有没有想到一些问题, 就是需求是否会有冲突.</p>

<p>假设男的30以下, 不帅, 不讨厌宠物, 那查询出来的记录就是B和C, 那这里会同时对房有要求, 但这种情况, 不算有冲突, 因为C的Codition是包含了B的, 所以只要有车和40W的房就行了.  但是如果男的30以上, 不帅, 不讨厌宠物, 那就A, B, C都是满足条件的, 但是A和C对车都有要求, 选哪个呢?  这时就要解决冲突了, 其中一种做法, 就是在不同的Condition上, 加上比重, 比如年龄看重点, 宠物看轻点, 那就以A的为准, 要20W以上的车了.</p>

<p>好玩吧?  所以, 把数据维度设成行记录来存储, 还可以把不同维度加上其它一些设置, 如比重等, 配置起来会比较方便.</p>

<p>不知道大家有什么意见?  欢迎拍砖.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS, Jasmine, Unit Test – Part 2 (Ajax & Behavior)]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2012/08/30/extjs-jasmine-unit-test-part-2-ajax-behavior-2/"/>
    <updated>2012-08-30T23:04:06+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2012/08/30/extjs-jasmine-unit-test-part-2-ajax-behavior-2</id>
    <content type="html"><![CDATA[<p>Ajax is a pretty common used feature now for every JS Rich application. How to test it is common headache for many application.</p>

<p>ExtJS has been adopted in the two companies I worked and am working for.  Hence, here I only show you how to test Ajax in ExtJS built application.</p>

<p>In my previous post <a href="http://thinkingincrowd.me/2012/08/13/extjs-jasmine-unit-test-part-1-philosophy-and-test-for-store/">ExtJS, Jasmine, Unit Test – Part 1 (Philosophy and Test for Store)</a>, the part on how to test Autoload <em>Ext.data.Store</em> simply override <em>Ext.lib.Ajax</em> so that it does nothing and <em>Ext.data.Store</em> is tested through manual loading data.</p>

<p>That is the simplest way but cannot fulfill the requirement to test real production code which uses Ajax feature.</p>

<p><strong>How real production code might look like if the application is built entirely by ExtJS?</strong></p>

<p>```javascript</p>

<pre><code>xxx.UiImpl = Ext.extend(xxx.Ui, {
    initComponent: function() {
        xxx.UiImpl.superclass.initComponent.call(this);

        this.emptyNameWarningMsg = 'Name is empty!';
        this.duplicateNameWarningMsg = 'Name has been in used!';
        this.nameField = Ext.getCmp('xxx.name');

        this.initEventHandlers();
    },

    initEventHandlers : function() {
        this.nameField.on('blur', this.validateName, this);
    },

    validateName: function(){
        var sName = this.nameField.getValue();
        if (sName == '') {
            this.nameField.markInvalid(this.emptyNameWarningMsg);
            return;
        }

        Ext.Ajax.request({
            url : config.appName() + "/foo/validateName",
            method : 'GET',
            params : {
                name : sName
            },
            success : function(data){
                if (data.responseText != '') {
                    this.nameField.markInvalid(this.duplicateNameWarningMsg);
                }
            },
            failure : function(data){
                alert("validate failure!");
            },
            scope: this
        });
    }
});
</code></pre>

<p>```</p>

<p>Above is a simple UI implementation class which extends from an UI class.  You can safely guess that this UI class simply has one name field which is bound with a Blur Event.  The Blur Event handler triggers an Ajax calls to validate whether the typed-in name is empty or duplicated within the system.  Pretty straightforward, right?</p>

<p><strong>Considering the Test Philosophy I mentioned in my last post, what contracts or behaviors we should test against here?</strong></p>

<p>Here are some examples:</p>

<ol>
<li>Contract between user and our system (blur event).  I would expect there would some code like this in my Jasmine Spec:</li>
</ol>


<p>```javascript</p>

<pre><code>oUI.nameField.fireEvent('blur');
</code></pre>

<p>```</p>

<ol>
<li>Contract between backend data structure and frontend handling on Ajax call.  I am expecting if I set the <em>responseText</em> from Ajax call to be not empty, the <em>nameField</em> in UI should be marked as invalid and show the <em>oUI.duplicateNameWarningMsg</em>.  Say, the response can be stub as:</li>
</ol>


<p>```javascript</p>

<pre><code>Ext.lib.Ajax.response({
    status: 200,
    responseText: 'Duplicate'
});
</code></pre>

<p>```</p>

<ol>
<li>Contract between implementation logic and UI behavior experienced by user.  The point mentioned above that <em>nameField</em> in UI should be marked as invalid and show the <em>oUI.duplicateNameWarningMsg</em> or <em>oUI.emptyNameWarningMsg</em> under different situations<strong>.</strong> Sample Spec code might be:</li>
</ol>


<p>```javascript</p>

<pre><code>oUI.nameField.fireEvent('blur');
expect(oUI.nameField.getActiveError()).toEqual(oUI.emptyNameWarningMsg);

oUI.nameField.setValue('Ken');
oUI.nameField.fireEvent('blur');
expect(oUI.nameField.getActiveError()).toEqual(oUI.duplicateNameWarningMsg);
</code></pre>

<p>```</p>

<ol>
<li>Other Contracts (e.g. Hardcode global variable or Element Id).  Why this is needed?  Because this where most of the change happens but it's very difficult to be aware of.  Sample Spec code might be:</li>
</ol>


<p>```javascript</p>

<pre><code>var oUI = Ext.getCmp('kentest');
</code></pre>

<p>```</p>

<p><strong>The Test Spec is already in mind but how can I use it to test against the production code?  </strong></p>

<p>I googled around and found one useful helper API - <a href="http://github.com/pivotal/jasmine-ajax">Jasmine-Ajax</a> : a set of helpers for testing AJAX requests under the Jasmine BDD framework for JavaScript.  However, now it only supports Prototype.js and jQuery.</p>

<p>I read the source and found it is not difficult to add support for ExtJS.  Hence, I modified it a bit.  Later I may submit a patch to github for this project and see whether it can be accepted.  Here I just attached the modified source first.   <a href="https://dl.dropbox.com/u/17182499/blog/2012/08/mock-ajax.js">mock-ajax</a></p>

<p>How should I include this helper class to use Jasmine to test the Ajax in ExtJS?</p>

<p>Configuration in POM.xml</p>

<p>```xml</p>

<pre><code>&lt;configuration&gt;
    &lt;preloadSources&gt;
        &lt;source&gt;adapter/ext/ext-base-debug.js&lt;/source&gt;
        &lt;source&gt;ext/ext-all-debug-w-comments.js&lt;/source&gt;
        &lt;source&gt;${project.basedir}/Resources/test/js/mock-ajax.js&lt;/source&gt;
        &lt;source&gt;${project.basedir}/Resources/test/js/global.js&lt;/source&gt;
    &lt;/preloadSources&gt;
...
&lt;configuration&gt;
</code></pre>

<p>```</p>

<p>Code in file globalTestStub.js change to be:</p>

<p>```javascript</p>

<pre><code>jasmine.Ajax.installMock();
</code></pre>

<p>```</p>

<p>How to write the Test Spec?</p>

<p>```javascript</p>

<pre><code>describe('Test Maintenance UI', function() {
    beforeEach(function() {
        jasmine.Ajax.useMock();
    });

    it('Maintenance UI should be initialized successfully', function() {
        var oUI = new xxx.UI({});
        expect(Ext.getCmp('kentest')).toBeTruthy();
    });

    it('Focus leaving name field should trigger unique validation.', function() {
        Ext.lib.Ajax.response({
            status: 200,
            responseText: 'Duplicate'
        });

        var oUI = Ext.getCmp('kentest');
        oUI.nameField.fireEvent('blur');
        expect(oUI.nameField.getActiveError()).toEqual(oUI.emptyNameWarningMsg);

        oUI.nameField.setValue('Ken');
        oUI.nameField.fireEvent('blur');
        expect(oUI.nameField.getActiveError()).toEqual(oUI.duplicateNameWarningMsg);
    });
});
</code></pre>

<p>```</p>

<p>Can you see how all above works now?  Please take it a trial and share your comment with me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS, Jasmine, Unit Test - Part 1 (Philosophy and Test for Store)]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2012/08/13/extjs-jasmine-unit-test-part-1-philosophy-and-test-for-store/"/>
    <updated>2012-08-13T23:02:18+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2012/08/13/extjs-jasmine-unit-test-part-1-philosophy-and-test-for-store</id>
    <content type="html"><![CDATA[<p>After the <a href="http://thinkingincrowd.me/2012/08/06/extjs-jasmine-maven-integration/">integration</a> for ExtJS, Jasmine and Maven is done, we should consider how the unit test should be done for some web application built by ExtJS.</p>

<p>My previous ExtJS projects experience are all for internal company usage in Retail or Logistics business, the UI is composed of plenty components and full of user interaction.  Hence, business logic are often intervened with UI behavior together.  This is also one of the reason previously we think it's difficult to go for JS Unit Test.  (Maybe just we are too inexperienced on that.  Please share your experience to us if you have any.)</p>

<p>Assuming I need to introduce JS Unit Test to a system without any Unit Test covered, what should the general JS Unit Test principles to be firstly considered?  My opinions are:</p>

<blockquote><ol>
<li><p>To test external contract against each ExtJS Component or JS function.  The external contract is where changes often take place.</p></li>
<li><p>To test business logic (data calculation/validation, etc.) because this is where the real value in the business.</p></li>
<li><p>Not to test the UI behavior (Window popup, Panel/Tree collapse/expand, Drap/Drop, Animation, etc.).  It's quite difficult to mimic and verify the UI behavior because you have to twist your mind somehow to "tranform" the UI behavior to manual control the "movement" and then verify it.  It's just writing even more UI logic to control other UI logic.</p></li>
<li><p>Not to test all Ajax requests because it's slow and actually should be considered as Integration Test.  It's better to mock the interface data to test the Ajax caller &amp; response handler.</p></li>
</ol>
</blockquote>

<p>Let's see some real Unit Test example.  (Here some assumptions are made on how the components are generated and used in System: UI are completely built by ExtJS Designer.  It may not be the best practice, but it's the way I think the real practice can be applied.)</p>

<p><strong>Ext.data.Store</strong></p>

<p>You might first wonder why Unit Test need to be done for Store component?  I got to tell you that I have met many bugs that are introduced because of fields' definition changed.  This is the major contract bound the Store with the caller.</p>

<p>Below is a typical xxx.Datastore.js file generated by Ext Designer.</p>

<p>```javascript</p>

<pre><code>Ext.ns('xxx');
xxx.DataStore = Ext.extend(Ext.data.JsonStore, {
    constructor: function(cfg) {
        cfg = cfg || {};
        xxx.DataStore.superclass.constructor.call(this, Ext.apply({
            storeId: 'xxx.DataStore',
            url: 'http://www.foo.com/stub',
            root: 'data.rows',
            totalProperty: 'data.totalCount',
            autoLoad: true,
            fields: [
                {
                    name: 'code'
                },
                {
                    name: 'name'
                }
            ]
        }, cfg));
    }
});
new xxx.DataStore();
</code></pre>

<p>```</p>

<p>How should we test it?  This is an autoLoad Store.  As a JS source file to be linked in for testing, I cannot use Jasmine spyOn to stub it.  That is because JS source file is loaded before Jasmine spyOn in Spec can ever be run.  The only thing I can think of is to override the Ext Ajax lib to not doing actual request call.</p>

<p>Code in file globalTestStub.js to override the Ajax lib:</p>

<p>```javascript</p>

<pre><code>Ext.lib.Ajax.request = function() {
  return {success: true};
};
</code></pre>

<p>```</p>

<p>Configuration in POM.xml</p>

<p>```xml</p>

<pre><code>&lt;configuration&gt;
    &lt;preloadSources&gt;
        &lt;source&gt;adapter/ext/ext-base-debug.js&lt;/source&gt;
        &lt;source&gt;ext/ext-all-debug-w-comments.js&lt;/source&gt;
        &lt;source&gt;${project.basedir}/Resources/test/js/globalTestStub.js&lt;/source&gt;
    &lt;/preloadSources&gt;
    &lt;jsSrcDir&gt;${project.basedir}/Resources/js&lt;/jsSrcDir&gt;
    &lt;jsTestSrcDir&gt;${project.basedir}/Resources/test/js&lt;/jsTestSrcDir&gt;
    &lt;sourceIncludes&gt;
        &lt;include&gt;xxx.DataStore.js&lt;/include&gt;
...
&lt;/configuration&gt;
</code></pre>

<p>```</p>

<p>ExtJS source and the globalTestStub.js are included in <em>preloadSources</em> so that all Stub/Mock code required for Unit Test can be initialized correctly before other JS sources and Test Spec files without polluting real production code.</p>

<p>How to write a Test Spec then?  Actually, there is no fixed way, but just a simple rule: to test the contract.</p>

<p>```javascript</p>

<pre><code>describe('xxx.Datastore', function() {
    it('should be able to initialized', function() {
        var oStore = Ext.StoreMgr.lookup('xxx.DataStore');
        expect(oStore).toBeTruthy();
    });

    it('should load data correctly', function() {
        var oStore = Ext.StoreMgr.lookup('xxx.DataStore');
        oStore.loadData({
            data: {
                rows: [
                    {
                        code: 'C1',
                        name: 'N1'
                    },
                    {
                        code: 'C2',
                        name: 'N2'
                    }
                ],
                totalCount: 2
            }
        });

        expect(oStore.getTotalCount()).toEqual(2);
        var oRecord = oStore.getAt(0);
        expect(oRecord.get('code')).toEqual('C1');
        expect(oRecord.get('name')).toEqual('N1');
    });
});
</code></pre>

<p>```</p>

<p>Unit Test for non-autoload Store would be similar but easier.</p>

<p>Beside how the Test is written, I would like to draw your attention to how I wrote the description for the Suite and the Spec.  I am not sure whether I understood the <a href="http://dannorth.net/introducing-bdd/">Behavior Driven Development</a> comprehensively because I am still learning it.  However, I think this simple mind change helps me to think about how the behavior should be more than just simply how to write Test to meet coverage.  It can even helps us to review our design whether particular code belongs to the right place.</p>

<p>Let's explore how Unit Test can be achieved more for ExtJS later.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS, Jasmine, Maven - Integration]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2012/08/06/extjs-jasmine-maven-integration/"/>
    <updated>2012-08-06T22:59:31+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2012/08/06/extjs-jasmine-maven-integration</id>
    <content type="html"><![CDATA[<p>After briefing <a href="http://thinkingincrowd.me/2012/08/05/extjs-jasmine-maven-why-i-am-working-on-them/">Why I am working on them</a>, let me show you how they can be integrated all together first.</p>

<p><a href="http://pivotal.github.com/jasmine/">Jasmine</a> is a BDD Test Framework which can be integrated in many environments.  At first, I want to integrate it with <a href="http://nodejs.org/">NodeJS</a> which I have been eager to use for a long time.  However, when using NodeJS in Windows environment, I encountered some strange error "Class not found: File" if I tried to start my local Weblogic server.  After I removed NodeJS installation path from environment variable PATH, the error is gone.</p>

<p>The other reason I decided not integrating Jasmine in NodeJS in our project is because it might be difficult for some people to learn a completely new stuff and it is also not compatible to our JAVA development environment &amp; process.  <a href="maven.apache.org">Maven</a> is a better choice for us now because we should be using it for our project's build management.</p>

<p>Let's see how it can be done.  Here, I assume you already know what Maven is and have your own project POM.xml.  Then, simply setup <a href="https://github.com/searls/jasmine-maven-plugin">jasmine-maven-plugin</a> in your POM.xml like below.</p>

<p>```xml</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.searls&lt;/groupId&gt;
    &lt;artifactId&gt;jasmine-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.2.0.0&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;test&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
    &lt;preloadSources&gt;
        &lt;source&gt;${project.basedir}/[SOME_PRELOAD_FILES_GOES_HERE]&lt;/source&gt;
    &lt;/preloadSources&gt;
    &lt;jsSrcDir&gt;${project.basedir}/Resources/js&lt;/jsSrcDir&gt;
    &lt;jsTestSrcDir&gt;${project.basedir}/Resources/test/js&lt;/jsTestSrcDir&gt;
    &lt;sourceIncludes&gt;
            &lt;include&gt;[TO_BE_TESTED_JS_FILES_GOES_HERE]&lt;/include&gt;
        &lt;include&gt;[TO_BE_TESTED_JS_FOLDER_GOES_HERE]/*.js&lt;/include&gt;
    &lt;/sourceIncludes&gt;
    &lt;specIncludes&gt;
        &lt;include&gt;[SPEC_JS_FOLDER_GOES_HERE]/*.js&lt;/include&gt;
    &lt;/specIncludes&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>```</p>

<p>After you modify those CAPITALIZED PLACEHOLDER to fit your own project, you can simply type "mvn test" in command line to see whether Jasmine is included into your Maven test lifecycle.  You should have something similar in output:</p>

<p>```bash</p>

<pre><code>[INFO] Executing Jasmine Specs
-------------------------------------------------------
 J A S M I N E   S P E C S
-------------------------------------------------------
[INFO]
Test Suite Name 1
  Spec 1
  Spec 2

Test Suite Name 2
  Spec 3

Results: 3 specs, 0 failures
</code></pre>

<p>```</p>

<p>If you encounter any error, please go check the documentation site of this plugin or leave a comment here.  The plugin setup should be quite strange forward.</p>

<p>File path in <em>sourceIncludes</em>, <em>specIncludes</em> are relative paths to <em>jsSrcDir</em> and <em>jsTestSrcDir</em>.  <em>preloadSources</em>, <em>sourceIncludes</em>, <em>specIncludes</em> are treated as ordered list so that you can properly arrange your JS and Jasmine Spec in correct order when your JS or Spec has some loading dependency.</p>

<p>OK, now preparation for Unit Test is done.  Let's see how Jasmine can be used to do Unit Test especially for ExtJS project together in my next post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS, Jasmine, Maven - Why I am working on them?]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2012/08/05/extjs-jasmine-maven-why-i-am-working-on-them/"/>
    <updated>2012-08-05T15:52:24+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2012/08/05/extjs-jasmine-maven-why-i-am-working-on-them</id>
    <content type="html"><![CDATA[<p>Before going into how to setup <a href="http://pivotal.github.com/jasmine/">Jasmine</a> to do Unit Test for <a href="www.sencha.com/products/extjs">ExtJS</a>, I think I should describe why I am doing this.</p>

<p>I have been using ExtJS for around 4 years.  My first company used HTML + ExtJS to build the UI while the current one use ExtJS completely to do that.  I have encountered lots of cases that well-tested behavior failed after some new features introduced in.</p>

<p>Everyone knows that it's because there lacks Unit Test.  However, there have never been any Unit Test done for Javascript in any project.  There are many of the reasons behind that, such as tight schedule, not enough attention etc.  But the most important reason that outweights or strengthens others is that Unit Test for Javascript is way too difficult than Java, especially when Javascript is used intensively to build the UI and implement business logics.</p>

<p>One of the reason makes Javascript hard to do Unit Test is due to good tools unavailability;  the other one is that most developers tend to not separating business logic from UI code quite clearly.</p>

<p>After the emergence of <a href="http://seleniumhq.org/">Selenium</a>, I have once thought it should be the right tool to address this issue.  However, after reading Selenium Doc and seeing what my previous colleagues did for recording &amp; playing, I think Selenium should be used mainly for Integration Test, not in Unit Test level.  My opinion is further strenghten after watching a video from Google Testing Expert and reading the blog from Martin Fowler:</p>

<blockquote><p><a href="http://www.infoq.com/cn/presentations/duannian-agile-test">让测试也敏捷起来</a> by 段念</p></blockquote>

<p><a href="http://martinfowler.com/bliki/TestPyramid.html">TestPyramid</a> by Martin Fowler</p>

<p><strong>The main points in TestPyramid are:</strong></p>

<blockquote><ol>
<li><p><strong>Low-level unit test should be many more than high level end-to-end testing through GUI.</strong></p></li>
<li><p><strong>Testing through UI is slow, brittle, expensive to write.</strong></p></li>
<li><p><strong>A rich javascript UI should have most of its UI behavior tested with javascript unit tests using something like Jasmine.</strong></p></li>
</ol>
</blockquote>

<p>Above is a long long purpose briefing, I hope it worthes to let you know the background and also agree with me on this.  I heard about Jasmine before reading the post by Martin Fowler, however, I kept thinking that it's quite difficult or even impossible to use Jasmine to test those ExtJS UI components.</p>

<p>Until I did sit down and really tried to use Jasmine to test the ExtJS code, I can say that Unit Test against ExtJS by Jasmine can be achieved at some level once we know what to test for.</p>

<p>In next post, I will show you the steps to bind ExtJS, Jasmine, Maven together to do the Unit Test and what I think we should test against.</p>
]]></content>
  </entry>
  
</feed>
