<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: NodeJS | Thinking in Crowd / 鹄思乱想]]></title>
  <link href="http://kenspirit.github.io/tags/nodejs/atom.xml" rel="self"/>
  <link href="http://kenspirit.github.io/"/>
  <updated>2013-06-17T06:32:46+08:00</updated>
  <id>http://kenspirit.github.io/</id>
  <author>
    <name><![CDATA[鹄思乱想]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Share code between Node.js and browser]]></title>
    <link href="http://kenspirit.github.io/blog/2013/04/13/share-code-between-nodejs-and-browser/"/>
    <updated>2013-04-13T12:59:00+08:00</updated>
    <id>http://kenspirit.github.io/blog/2013/04/13/share-code-between-nodejs-and-browser</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>When you are writing a Node.js based web application, it comes to a demand to share code between Node.js and browser because both the frontend and backend are written in JavaScript.  Some utility APIs, such as validation, data processing, are the common cases.</p>

<p>The philosophy of organizing code in Node.js, current trend also, is modularization.  Each module file has its own execution context, requires its dependent APIs from other modules and publishes its own APIs out for other modules.</p>

<p>Hence, the code sharing between Node.js and browser requires the code to be used as the same way in browser.</p>

<h2>Situations and Solutions</h2>

<p>Things work differently regarding the JS and modules loading mechanism.  Because in browser, it works asynchronously while in Node.js it is synchronous.  In browser, we cannot directly do inline require like Node.js:</p>

<p>```javascript
var a = xxx;
a.foo();</p>

<p>var b = require('b');
b.bar();
```</p>

<p>There are two kinds of situations:</p>

<h3>Modularization already realized for browser code</h3>

<p>If you have already modularized your JS code for browser and used some AMD / CMD script loader, such as <a href="http://requirejs.org/">RequireJS</a>, or <a href="http://seajs.org/">SeaJS</a>, you might expect your life would be easier.  However, this is not the case.</p>

<p>The require must be like below in order to make sure all dependent modules to be loaded successfully and then execute the code which uses them.</p>

<p>```javascript
define(['./b'], function (b) {</p>

<pre><code>var a = xxx;
a.foo();
b.bar();

return {
    bla: function(){
        console.log('bla');
    }
};
</code></pre>

<p>});
```</p>

<p>We can see that there is quite some syntax different between Node.js style and the AMD / CMD one in browser.</p>

<p>To overcome this incompatibility, there are two main approaches.</p>

<ul>
<li><p>Directly add boilerplate code in one side to fit the other</p>

<ol>
<li>Some sample manual boilerplate code and also more explanation can be found <a href="http://www.2ality.com/2011/11/module-gap.html">here</a>.</li>
<li><a href="https://github.com/ajaxorg/node-amd-loader">node-amd-loader</a>: Add one extra line in Node.js module to load AMD style module.</li>
<li>The <a href="https://github.com/jrburke/amdefine">amdefine</a> for RequireJS: Special boilerplate code in Node.js module and then can be stripped out by <a href="https://github.com/jrburke/amdefine#optimizer">RequireJS Optimizer</a>.</li>
</ol>
</li>
<li><p>Build process to handle the boilerplate</p>

<ol>
<li><a href="https://github.com/substack/node-browserify">browserify</a>: Recursively analyze all the <code>require()</code> calls in your app in order to build a bundle you can serve up to the browser in a single <code>&lt;script&gt;</code> tag.</li>
<li><a href="https://github.com/medikoo/modules-webmake">modules-webmake</a>: Bundle CommonJS/Node.js modules for web browsers.</li>
<li><a href="https://github.com/kenspirit/webassemble">webassemble</a>: Based on modules-webmake.  Auto bundle CommonJS/Node.js packages for web browsers.</li>
</ol>
</li>
</ul>


<p>Personally, I prefer introducing extra build process to handle the boilerplate for me.</p>

<p>The advantages of build process boilerplate are:</p>

<ol>
<li>Boilerplate code is brittle and subject to change.  Adding it to every file makes future change harder.  If some build process can automatically remove them, why not use the build process to automatically add them?</li>
<li>Modularization is good but for production environment in browser, it is always better to minimize network request to load JS file.  Most of the time, module files are bundled into single package for one call.  If build process need to be introduced to handle it, it would be great to integrate sharing logic into it also.</li>
<li>If the boilerplate is introduced in build process, it is better to discover potential error during development cycle instead of last minute preproduction testing.</li>
</ol>


<p>You may have concern on effectiveness during development cycle.  However, if you can make good use of a good IDE, say <a href="http://www.sublimetext.com/">Sublime Text</a> and some task runner, say <a href="http://gruntjs.com/">Grunt</a>, it's just a couple of seconds' waiting after a hotkey command after saving your JS file in IDE.  It might just be the time you switch from IDE to browser and press F5.</p>

<h3>Legacy or namespace browser code style</h3>

<p>Although it's seldom the case that when you are using such hot tech of Node.js but still need to stick to the old style in browser, it's actually easier to share your Node.js code under this circumstance.</p>

<p>The webmake and webassemble mentioned above is easy to bundle your modules under global or a particular namespace.</p>

<p>So, what is my favorite choice?  Write the Node.js style code and share them to browser by webassemble.  Why not webmake?  Because the webassemble is made by me. :P</p>

<p>So tell me what is yours.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A response pends forever issue in MongoDB, Connect and Node.js]]></title>
    <link href="http://kenspirit.github.io/blog/2012/12/05/a-response-pends-forever-issue-in-mongodb-connect-and-nodejs/"/>
    <updated>2012-12-05T21:08:00+08:00</updated>
    <id>http://kenspirit.github.io/blog/2012/12/05/a-response-pends-forever-issue-in-mongodb-connect-and-nodejs</id>
    <content type="html"><![CDATA[<p><strong>My ignorance</strong><br/>
When I first switched to use <a href="https://github.com/masylum/connect-mongodb">connect-mongodb</a> to replace the MemoryStore in <a href="https://github.com/senchalabs/connect">Connect</a>, I found that the homepage of my pet project cannot be even loaded and it seems the response is kept waiting there.  If I switched back to use MemoryStore, it's all fine.  There must be something wrong when I am using <a href="http://www.mongodb.org/">MongoDB</a> for session management.</p>

<p>First, I dig into the <em>session.js</em> in Connect.  Around line 267:
```javascript connect/lib/middleware/session.js</p>

<pre><code>// proxy end() to commit the session
var end = res.end;
res.end = function(data, encoding){
  res.end = end;
  if (!req.session) return res.end(data, encoding);
  debug('saving');
  req.session.resetMaxAge();
  req.session.save(function(){
    debug('saved');
    res.end(data, encoding);
  });
};
</code></pre>

<p>```</p>

<p>After opening the debug feature in <a href="http://nodejs.org">Node</a>, I found that it's never going into the callback of <em>session.save()</em>.  Hence, the 'saved' message is never printed in the console after 'saving' and the response is never ending.</p>

<p>Why would this happened?  I kept tracing the code and found that <em>session.save()</em> in Connect is calling the <em>sessionStore.set()</em> method.  The <em>MongoStore.set()</em> method in <em>connect-mongodb.js</em> is just purely calling <em>collection.update()</em> and no much magic there.  However, it seems the <em>update()</em> method call has either no err and data coming back.  Is there something wrong with the MongoDB or the Collection?</p>

<p>MongoDB log doesn't seems to have any query or update action recorded and I just found that there are 10 connections started every time I started my app, but I remembered there were 5 connections (default pool size) before (Actually, I haven't noticed that this is the phenomenon of the problem I have at that time yet).</p>

<p>Without any clue, I checked the initialization of the MongoStore and find below code:
```javascript</p>

<pre><code>if (server_config.isConnected()) {
  authenticateAndGetCollection(callback);
} else {
  server_config.connect(db, function (err) {
    if (err) callback(Error("Error connecting (" + (err instanceof Error ? err.message : err) + ")"));
      authenticateAndGetCollection(callback);
    });
}
</code></pre>

<p>```</p>

<p>It turns out that the flow goes into <em>server_config.connect()</em> again.  But why?  DB should be initialized in below code which is intended to encapsulate all DB operation.
```javascript DbManager.js</p>

<pre><code>DbManager = (function() {
  var db = new Db('tyt', new Server('127.0.0.1', 27017, {auto_reconnect: true}, {}), {safe: true});
  db.open(function(){});

  return {
    getDb: function() {
        return db;
    }
  }
})();

exports.DbManager = DbManager;
</code></pre>

<p>```</p>

<p>```javascript In my node app.js</p>

<pre><code>var express = require('express')
  , DbManager = require('./db.js').DbManager
  , mongoStore = require('connect-mongodb');

var app = module.exports = express();

// Configuration
app.configure(function(){
  app.use(express.session({
      secret: 'kenspirit',
      key: 'tt.sid',
      cookie: {secure: false, maxAge: 300000},
      store: new mongoStore({db: DbManager.getDb()})
  }));
});
</code></pre>

<p>```</p>

<p>If you are familiar with Node, you may have already noticed what I haven't done right here.  I am assuming the DB should be connected and ready for use already as I have called <em>db.open()</em> during DbManager's construction.  However, Async is the most importance concept in Node, <em>db.open()</em> takes my callback will immediately return and it doesn't guarantee it's opened already.  If I change to below code, problem solved.</p>

<p>```javascript</p>

<pre><code>var db = DbManager.getDb();
db.open(function(err, db) {
  if (db) {
    app.use(express.session({
      secret: 'kenspirit',
      key: 'tt.sid',
      cookie: {secure: false, maxAge: 300000},
      store: new mongoStore({db: db})
    }));
   }
});
</code></pre>

<p>```</p>

<p><strong>The root of not responding</strong><br/>
I wonder where is the actual source to make the response kept waiting?  I have configured the <em>auto_reconnect</em> already.  Later I found that in mongodb:
```javascript mongodb/lib/mongodb/db.js
  Db.prototype.open = function(callback) {</p>

<pre><code>...
self._state = 'connecting';
...
self.serverConfig.connect(self, {firstCall: true}, function(err, result) {
  if(err != null) {
    // Set that db has been closed
    self.openCalled = false;
    // Return error from connection
    return callback(err, null);
  }
  // Set the status of the server
  self._state = 'connected';
  // Callback
  return callback(null, self);
});
...
</code></pre>

<p>  };</p>

<p>  Db.prototype._executeInsertCommand = function(db_command, options, callback) {</p>

<pre><code>...
// If the pool is not connected, attemp to reconnect to send the message
if(self._state == 'connecting' &amp;&amp; this.serverConfig.autoReconnect) {
  process.nextTick(function() {
    self.commands.push({type:'insert', 'db_command':db_command, 'options':options, 'callback':callback});
  })
}
...
</code></pre>

<p>  ;}
```</p>

<p>```javascript mongodb/lib/connection/server.js
  Server.prototype.connect = function(dbInstance, options, callback) {</p>

<pre><code>...
// Force connection pool if there is one
if(server.connectionPool) server.connectionPool.stop();
...
// Create connection Pool instance with the current BSON serializer
var connectionPool = new ConnectionPool(this.host, this.port, this.poolSize, dbInstance.bson,  this.socketOptions);
...
// Set up on connect method
connectionPool.on("poolReady", function() {
  // Create db command and Add the callback to the list of callbacks by the request id (mapping outgoing messages to correct callbacks)
  var db_command = DbCommand.NcreateIsMasterCommand(dbInstance, dbInstance.databaseName);
  // Check out a reader from the pool
  var connection = connectionPool.checkoutConnection();
  // Set server state to connEcted
  server._serverState = 'connected';
  // dbInstance._state = 'connected';  If I add this line here, even if my code doesn't do any change, it works.
  ...
});
</code></pre>

<p>  };
```</p>

<p>Finally, the root cause is found.  Normally, when <em>db.open()</em> is called, it sets its <em>_state = 'connecting'</em>, and it then will call <em>server.connect()</em> to create connection pool and in the callback, it sets its <em>_state = 'connected'</em> again.  However, my case is that the second call <em>server.connect()</em> in MongoStore.js first make the first connection pool stops and then creates a new connection pool again(This should be where makes the mongo db log has 10 connections opened).  Somehow, the callback in normal flow cannot be executed so that <em>db._state</em> has not been set to 'connected'.  What is more, the callback set in <em>MongoStore.js</em> doesn't set the <em>db._state</em> to 'connected'.  The <em>db._state</em> is remained in 'connecting' forever which makes my update command keep pushing to its commands stack.</p>

<p><strong>Most appropriate way to initialize MongoDB and its connections in Node.js</strong><br/>
I began to wonder what is the "most appropriate way" to initialize MongoDB and manage its connections and googled around.</p>

<p>At first, I found a similar question asked in <a href="http://stackoverflow.com/questions/10656574/how-to-manage-mongodb-connections-in-a-nodejs-webapp">StackOverFlow</a>.<br/>
However, the reply doesn't seem to be reasonable.  It recommands opening a new connection (actually, a DB and Connection Pool there) per request.  And it said it's due to MongoDB is asynchronous.  It's pretty confusing and the asynchronous mechanism in Node should be achieved by callback instead of creating new connection per request.  If so, what is the point of using pool then?  This approach should be more slow.</p>

<p>Later I found out a reply from the author of node-mongodb-native in <a href="http://stackoverflow.com/questions/10307994/where-can-i-find-complete-documentation-concerning-node-mongodb-native/10349450#10349450">StackOverFlow</a> too.  It clearly stated "DO NOT call open on each request.".</p>

<p>I believe only opening MongoDB once with appropriate pool size and initialize node application in the <em>db.open()</em> callback should be the right way to go.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS, Jasmine, Maven - Integration]]></title>
    <link href="http://kenspirit.github.io/blog/2012/08/06/extjs-jasmine-maven-integration/"/>
    <updated>2012-08-06T22:59:31+08:00</updated>
    <id>http://kenspirit.github.io/blog/2012/08/06/extjs-jasmine-maven-integration</id>
    <content type="html"><![CDATA[<p>After briefing <a href="http://www.thinkingincrowd.me/blog/2012/08/05/extjs-jasmine-maven-why-i-am-working-on-them/">Why I am working on them</a>, let me show you how they can be integrated all together first.</p>

<p><a href="http://pivotal.github.com/jasmine/">Jasmine</a> is a BDD Test Framework which can be integrated in many environments.  At first, I want to integrate it with <a href="http://nodejs.org/">NodeJS</a> which I have been eager to use for a long time.  However, when using NodeJS in Windows environment, I encountered some strange error "Class not found: File" if I tried to start my local Weblogic server.  After I removed NodeJS installation path from environment variable PATH, the error is gone.</p>

<p>The other reason I decided not integrating Jasmine in NodeJS in our project is because it might be difficult for some people to learn a completely new stuff and it is also not compatible to our JAVA development environment &amp; process.  <a href="maven.apache.org">Maven</a> is a better choice for us now because we should be using it for our project's build management.</p>

<p>Let's see how it can be done.  Here, I assume you already know what Maven is and have your own project POM.xml.  Then, simply setup <a href="https://github.com/searls/jasmine-maven-plugin">jasmine-maven-plugin</a> in your POM.xml like below.</p>

<p>```xml</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.searls&lt;/groupId&gt;
    &lt;artifactId&gt;jasmine-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.2.0.0&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;test&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
    &lt;preloadSources&gt;
        &lt;source&gt;${project.basedir}/[SOME_PRELOAD_FILES_GOES_HERE]&lt;/source&gt;
    &lt;/preloadSources&gt;
    &lt;jsSrcDir&gt;${project.basedir}/Resources/js&lt;/jsSrcDir&gt;
    &lt;jsTestSrcDir&gt;${project.basedir}/Resources/test/js&lt;/jsTestSrcDir&gt;
    &lt;sourceIncludes&gt;
            &lt;include&gt;[TO_BE_TESTED_JS_FILES_GOES_HERE]&lt;/include&gt;
        &lt;include&gt;[TO_BE_TESTED_JS_FOLDER_GOES_HERE]/*.js&lt;/include&gt;
    &lt;/sourceIncludes&gt;
    &lt;specIncludes&gt;
        &lt;include&gt;[SPEC_JS_FOLDER_GOES_HERE]/*.js&lt;/include&gt;
    &lt;/specIncludes&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>```</p>

<p>After you modify those CAPITALIZED PLACEHOLDER to fit your own project, you can simply type "mvn test" in command line to see whether Jasmine is included into your Maven test lifecycle.  You should have something similar in output:</p>

<p>```bash</p>

<pre><code>[INFO] Executing Jasmine Specs
-------------------------------------------------------
 J A S M I N E   S P E C S
-------------------------------------------------------
[INFO]
Test Suite Name 1
  Spec 1
  Spec 2

Test Suite Name 2
  Spec 3

Results: 3 specs, 0 failures
</code></pre>

<p>```</p>

<p>If you encounter any error, please go check the documentation site of this plugin or leave a comment here.  The plugin setup should be quite strange forward.</p>

<p>File path in <em>sourceIncludes</em>, <em>specIncludes</em> are relative paths to <em>jsSrcDir</em> and <em>jsTestSrcDir</em>.  <em>preloadSources</em>, <em>sourceIncludes</em>, <em>specIncludes</em> are treated as ordered list so that you can properly arrange your JS and Jasmine Spec in correct order when your JS or Spec has some loading dependency.</p>

<p>OK, now preparation for Unit Test is done.  Let's see how Jasmine can be used to do Unit Test especially for ExtJS project together in my next post.</p>
]]></content>
  </entry>
  
</feed>
